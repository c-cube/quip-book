<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quip: Quick Proofs</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/design.html"><strong aria-hidden="true">1.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="intro/example.html"><strong aria-hidden="true">1.2.</strong> First example</a></li><li class="chapter-item expanded "><a href="intro/for-atp.html"><strong aria-hidden="true">1.3.</strong> For the Theorem Prover</a></li><li class="chapter-item expanded "><a href="intro/for-proof-checkers.html"><strong aria-hidden="true">1.4.</strong> For the Proof Checker</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">2.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/terms.html"><strong aria-hidden="true">2.1.</strong> Terms</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Substitutions</div></li><li class="chapter-item expanded "><a href="reference/clauses.html"><strong aria-hidden="true">2.3.</strong> Clauses</a></li><li class="chapter-item expanded "><a href="reference/rules.html"><strong aria-hidden="true">2.4.</strong> Proof Rules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/rules-atomic.html"><strong aria-hidden="true">2.4.1.</strong> Atomic rules</a></li><li class="chapter-item expanded "><a href="reference/rules-composite.html"><strong aria-hidden="true">2.4.2.</strong> Composite rule</a></li><li class="chapter-item expanded "><a href="reference/rules-box.html"><strong aria-hidden="true">2.4.3.</strong> Box rules</a></li></ol></li><li class="chapter-item expanded "><a href="reference/example.html"><strong aria-hidden="true">2.5.</strong> Full example</a></li><li class="chapter-item expanded "><a href="reference/more-boxing.html"><strong aria-hidden="true">2.6.</strong> More on boxing</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> S-expression Format</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Binary Format</div></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">5.</strong> Tools</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Quip: Quick Proofs</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Quip documentation. Quip (&quot;Quick Proofs&quot;) is an experimental
proof format for first-order and higher-order automatic theorem provers,
designed to be easy to produce, and reasonably easy to check.</p>
<p>There are two sides to this documentation:</p>
<ul>
<li>the point of view of theorem provers, SMT solvers, etc.
that might <em>produce</em> Quip proofs;</li>
<li>the point of view of proof checkers that aim at validating such proofs.</li>
</ul>
<p><strong>NOTE</strong>: the proof format is experimental and its design will most likely
fluctuate a lot for a while, as checkers and proof-producing provers are
developed.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="overall-design"><a class="header" href="#overall-design">Overall design</a></h2>
<p>A Quip proof is organized around a few main notions: <em>terms</em>, <em>substitutions</em>,
<em>clauses</em>, and <em>proof steps</em>.</p>
<ul>
<li>
<p><strong>Terms</strong> are expressions in a simple higher-order logic similar to the ones
of HOL light, HOL, Isabelle/HOL, etc. It features prenex polymorphism,
applications, equality, variables, and lambda abstractions.</p>
<p>An example term might be \(  p~ x = (\lambda y. f~ x~ y = y) \)
where \( p \) is a predicate symbol and \( f \) a function symbol.
We use here a ML-like syntax with currying.</p>
</li>
<li>
<p><strong>Substitutions</strong> are finite mappings from variables to terms,
noted as such: \( \{ x_1 \mapsto t_1, \ldots, x_n \mapsto t_n \} \).</p>
<p><em>Applying</em> a substitution to a term yields a new term, where the variables
have been replaced by their image in the substitution (or kept if they're
not bound in the substitution)</p>
</li>
<li>
<p><strong>Clauses</strong> are sets of literals<sup class="footnote-reference"><a href="#1">1</a></sup>, where each literal is a tuple
\( sign, term \). The <em>sign</em> of a literal is a boolean
that indicates whether the term is positive (<code>true</code>) or negative (<code>false</code>).
A negative literal <code>(false, t)</code> fundamentally <em>represents</em> \( \lnot t \)
but is distinct from the term \( \lnot t \) because the polarity (the sign)
is only relevant in the context of a clause.</p>
<p>We will denote a negative literal as \( - t \) and a positive
literal as \( + t \).</p>
<p>An example clause might be: \[ \{ - (a=b), - (c=d), + ((f~ a~ c) = (~f b~ d)) \} \]
It represents the basic congruence lemma:
\[ a=b, c=d \vdash f~ a~ c = f~ b~ d    \]</p>
</li>
<li>
<p><strong>Proof steps</strong> are the basic building blocks of proofs. A proof step
is composed of:</p>
<ul>
<li>a <strong>rule</strong>, which indicates how to process this step;</li>
<li>a <strong>conclusion</strong>, which is the clause that this proof step produces;</li>
<li>a set of <strong>premises</strong>, which are inputs to the proof step.</li>
<li>optionally, some additional arguments such as terms, substitutions, etc.</li>
</ul>
<p>A proof step asserts (via its particular rule) that the set of premises
implies its conclusion. In practice not all the elements of a step might be
explicitly written down! For example \( \text{refl}~ t \) (with \( t \) a term)
is a basic proof step with rule &quot;refl&quot;, no premises,
and conclusion  \( \{ + (t = t) \} \).</p>
</li>
</ul>
<p>A distinguishing feature of Quip compared to some other proof formats such as
the one in VeriT is that the rules are high-level and require proof checkers
to do more work in order to verify them. In exchange, the hope is that
we get more concise proofs that are also easier to produce from theorem provers.</p>
<p><strong>TODO</strong>: citations for VeriT</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Clauses can alternatively be seen as classical sequents, with negative elements
on the left of \( \vdash \), and positive elements on the right of it.</p>
</div>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>This is a very simple SMT problem in the category <code>QF_UF</code>, representing
the problem \( a=b \land f~a = c \vdash f~b = c \) by trying to contradict it:</p>
<pre><code class="language-smtlib2">(set-logic QF_UF)
(declare-sort u 0)
(declare-fun a () u)
(declare-fun b () u)
(declare-fun c () u)
(declare-fun f (u) u)

(assert (= a b))
(assert (= (f a) c))
(assert (not (= (f b) c)))
(check-sat)
(exit)
</code></pre>
<p>With <a href="https://github.com/c-cube/sidekick">Sidekick</a>'s experimental
proof producing mode, we solve this problem (it replies &quot;UNSAT&quot;):</p>
<pre><code class="language-sh">$ sidekick example-pb.smt2 -o example-proof.quip
Unsat (0.003/0.000/0.000)
</code></pre>
<p>And we get the following proof:</p>
<pre><code class="language-sexp">(quip 1
 (steps ()
  ((deft $t1 (f a))
   (deft $t2 (= $t1 c))
   (deft $t3 (= a b))
   (deft $t4 (f b))
   (deft $t5 (= c $t4))
   (stepc c0 (cl (- $t2) (- $t3) (+ $t5))
    (cc-lemma (cl (- $t2) (- $t3) (+ $t5))))
   (stepc c1 (cl (- $t5)) (assert (not $t5)))
   (stepc c2 (cl (+ $t3)) (assert $t3))
   (stepc c3 (cl (+ $t2)) (assert $t2))
   (stepc c4 (cl )
    (hres (init (ref c0)) (r1 (ref c3)) (r1 (ref c2)) (r1 (ref c1)))))))
</code></pre>
<p><strong>NOTE</strong>: the proof uses the S-expression format, but I do hope to have a
more efficient binary format relatively early on.</p>
<h2 id="detailed-explanation"><a class="header" href="#detailed-explanation">Detailed explanation</a></h2>
<ul>
<li>
<p>proof start with <code>(quip &lt;version&gt; &lt;proof&gt;)</code>. For now <code>version</code> is 1.</p>
</li>
<li>
<p><code>(steps (&lt;assumptions&gt;) (&lt;steps&gt;))</code> is the main composite proof rule.
Let's ignore the assumptions for now. Each step in this rule
is either a symbol definition (see below) or a <code>(stepc &lt;name&gt; &lt;clause&gt; &lt;proof&gt;)</code>,
which introduce a name for an intermediate lemma (the clause)
as proved by the sub-proof.</p>
<p>A side-effect of this is that you can have partially correct<sup class="footnote-reference"><a href="#1">1</a></sup> proofs
if a step is used correctly in the remainder of the proof, but its proof is
invalid.</p>
</li>
<li>
<p><code>(deft $t1 (f a))</code> is a term definition.
It defines the new symbol <code>$t1</code> as a syntactic shortcut for
the term <code>(f a)</code>, to be expanded as early as possible by the proof checker.</p>
<p>Similarly, <code>$t5</code> is short for <code>(= c (f b))</code>.</p>
<p>This kind of definition becomes important in larger proofs, where re-printing
a whole term every time it is used would be wasteful and would bloat proof
files. Using definitions we can preserve a lot of sharing in the proofs.</p>
</li>
<li>
<p><code>(stepc c0 …)</code> is the first real step of the proof.
Here, <code>c0</code> is the clause <code>{ - $t2, - $t3, + $t5</code>,
and is proved by the proof <code>(cc-lemma …)</code> (a congruence closure lemma,
i.e. a tautology of equality). It is, in essence, the proof we seek;
the rest of the steps are used to derive a contradiction by
deducing &quot;false&quot; from <code>c0</code> and our
initial assumptions.</p>
</li>
<li>
<p>the steps deducing <code>c1</code>, <code>c2</code>, and <code>c3</code> do so by using <code>assert</code>
(meaning that the clause is actually an assumption of the initial problem),
and then &quot;preprocessing&quot; them.</p>
<p>For <code>(stepc c1 (cl (- $t5)) (hres (init (assert (not $t5))) (p1 (refl $t5))))</code> we get the following
tree:</p>
<p>\[
\cfrac{
\cfrac{}{$t5 ~\tiny{(assume)}} \qquad
\cfrac{}{$t5 = $t5  ~\tiny{(refl)}}
}{$t5  ~\tiny{(para1)}}
\]</p>
<p>In this tree we can see the general shape of preprocessing terms: assume the
initial term <code>± t</code>, prove <code>+ (t = u)</code> (where <code>u</code> is the simplified version),
and then use boolean paramodulation to obtain <code>± u</code>.</p>
<p>It just so happens
that no meaningful simplification occurred and so <code>t</code> and <code>u</code> are the same,
and sidekick did not shorten the proof accordingly into
<code>(stepc c1 (cl (- $t5)) (assert (not $t5)))</code></p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>or partially incorrect, depending on your point of view. Glass half-full
and all that.</p>
</div>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="quip-for-the-automatic-theorem-prover"><a class="header" href="#quip-for-the-automatic-theorem-prover">Quip for the Automatic Theorem Prover</a></h2>
<p>Quip is biased towards being easy to <em>produce</em> from theorem provers and SMT
solvers, while remaining reasonably efficient to check.</p>
<p>The easiness comes from several aspects:</p>
<ul>
<li>
<p>redundancy in rules: many rules will have a general form (e.g. a congruence
closure lemma, or hyper-resolution with \( n \) steps),
and some shorter forms for the common case (e.g. unary resolution
or the reflexivity rule).</p>
</li>
<li>
<p>rules can be quite high-level, requiring the proof checkers to reimplement
congruence closure, resolution, etc.</p>
</li>
<li>
<p>the proof rules do not need to always specify their result, only enough
information that the conclusion can be reconstructed.</p>
</li>
<li>
<p>proofs are based on a <em>proof language</em> (&quot;proof terms&quot;) that allow for easy
composition of several steps. This way it's not necessary to name each single
clause occurring in the proof.</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="quip-for-the-proof-checker"><a class="header" href="#quip-for-the-proof-checker">Quip for the Proof Checker</a></h1>
<p>Quip's design favors the production of proofs, not their checking. However,
proof checking should still be implementable in an efficient way.</p>
<p>A proof checker must implement a few core algorithms to be able to verify proofs
(not to mention the particular set of theories it might support).
These are:</p>
<ul>
<li>
<p><strong>Congruence Closure</strong>:
equality is central to Quip, and most equality proofs
will be of the shape \( t_1=u_1, \ldots, t_n = u_n \vdash t=u \).
These can be checked in \( O(n ~ log(n)) \) time using Congruence Closure
(See for example the [EGG paper]).</p>
</li>
<li>
<p><strong>Resolution</strong>: 
clause-level reasoning is done via multiple steps of resolution and
boolean paramodulation.</p>
<p>The core rules are resolution:</p>
<p>\[
\cfrac{C_1 \lor l  \qquad         C_2 \lor \lnot l}{ C_1 \lor C_2 }
\]</p>
<p>and boolean paramodulation (where \(t\) is a boolean term):</p>
<p>\[
\cfrac{C_1 \lor (t = u)  \qquad         C_2 \lor t}{ C1 \lor C_2 \lor u }
\]</p>
<p>In practice, in the proof format, &quot;hres&quot; is the rule used to perform
a series of such steps from an initial clause.</p>
</li>
<li>
<p><strong>Instantiation</strong>:
A clause \( C \) contains free variables \( \{ x_1, \ldots, x_n \} \).
Given a substitution \( \sigma \triangleq \{ x_1 \mapsto t_1, \ldots, x_n \mapsto t_n \} \), we
can deduce \( C\sigma \).</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This chapter contains<sup class="footnote-reference"><a href="#1">1</a></sup> a detailed specification of the proof language constructs.
For the concrete file formats, see <a href="">the S-expr format</a> and <a href="">Binary format</a> chapters.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>will eventually contain. 😇</p>
</div>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="terms"><a class="header" href="#terms">Terms</a></h1>
<p>Terms belong to higher-order logic, with prenex polymorphism. In general
we denote terms as \( t \) or \( u \) (with indices if needed).</p>
<p>(TODO: provide some citations)</p>
<p>(TODO: specify types)</p>
<p>The term can be constructed in the following ways:</p>
<ul>
<li>
<p><strong>Variables</strong>, denoted \( x, y, z \). They can be free, or bound. Variables
are typed.</p>
</li>
<li>
<p><strong>Applications</strong>, denoted <code>(f t1 t2 t3)</code>. Partial applications are transparent,
meaning that <code>(f t1 t2 t3)</code> is short for <code>(((f t1) t2) t3)</code>.</p>
</li>
<li>
<p><strong>Constants</strong>, denoted \( a, b, c, f, g, h \)
(where \(a,b,c\) are of atomic type and \(f, g, h\)
are functions by convention).</p>
<p>Polymorphic constants are applied to type arguments. Quip does not accept
a term made of a partially applied constant: polymorphism constants must always
be applied to enough type arguments.</p>
<p><strong>NOTE</strong>:
This does <em>not</em> include constants introduced by the prover using <code>(deft &lt;name&gt; &lt;term&gt;)</code> steps.
In that construct, say <code>(deft c (f a b))</code>, <code>c</code> and <code>(f a b)</code> are considered syntactically
equal; the proof checker can just expand <code>c</code> into <code>(f a b)</code> at parse time
and then forget entirely about <code>c</code>.</p>
</li>
<li>
<p><strong>Binders</strong>, such as \( \lambda (x:\tau). t \), or \( \forall (x:\tau). t \).
The latter is a shortcut for the application
\( \text{forall}~ (\lambda (x:\tau). term) \)
(where \( \text{forall} \)
is a constant of type \( \Pi a. (a \to \text{bool}) \to \text{bool} \) ).</p>
<p>With lambda-abstraction comes
\( \beta\)-reduction <!--, and \\( \eta \\)-expansion -->
(more details in <a href="reference/./rules.html">the rules section</a>).</p>
</li>
<li>
<p><strong>Box</strong> is a special term constructor that has no logical meaning.
We denote it <code>(box &lt;clause&gt;)</code>, and it is equivalent to the boolean term
represented by the clause. The use case of box is to hide the clause within
so that it appears as an atomic constant to most
rules but the ones specifically concerned with handling <code>box</code>.</p>
<p>For example <code>(box (cl (- (forall (x:τ) (p x))) (+ (p a))))</code>
represents the boolean term \( \lnot (\forall x:τ. p~ x) \lor p~ a \).</p>
<p>The benefit of <code>box</code> becomes apparent when one tries to use clauses to
represent conditional proofs. If I want to represent that I have a proof
of <code>A</code> assuming a proof of <code>B</code>, where <code>B</code> is a clause and not just a literal,
and <code>A</code> is the clause <code>{l_1, …, l_n}</code>, then
the simplest way to do so is: <code>(cl (cl l_1 … l_n (- (box B))))</code>.</p>
<p>See <a href="reference/./rules.html#box">the rules about box</a>.</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="clauses"><a class="header" href="#clauses">Clauses</a></h1>
<p>We denote clauses as <code>(cl &lt;lit&gt;*)</code>. The empty clause is therefore <code>(cl)</code>.
Each literal is <code>(&lt;sign&gt; &lt;term&gt;)</code> with the sign being either <code>+</code> or <code>-</code>
(for a clause-level negation).</p>
<p>For example, <code>(cl (- true) (+ (= b b)))</code> represents the clause
\( \lnot \top \lor b=b \), or the sequent \( \top \vdash b=b \).</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="proof-rules"><a class="header" href="#proof-rules">Proof Rules</a></h1>
<p>Rules form an expression language designed to only return valid clause
(i.e. theorems, or assumptions of the problem). Most rules are of the atomic kind
(they take arguments but look like a function application);
the main <a href="reference/./rules-composite.html">structuring rule</a> permits the definition
of named intermediate steps. This is also necessary to introduce sharing in a proof,
where some clause might be proved once but used many times.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="atomic-rules"><a class="header" href="#atomic-rules">Atomic rules</a></h1>
<ul>
<li>
<p><strong>ref</strong> (<code>(ref &lt;name&gt;)</code>): returns a proof previously defined using <code>stepc</code>
(see <a href="reference/rules-atomic.html#composite-proofs">composite proofs</a> below) or a unit clause
corresponding to a local assumption of <code>steps</code>.
There is no need to re-prove anything, we assume the step was valid and
just reuse its conclusion.</p>
<p>In other words, <code>(ref c5)</code> coming after <code>(defc c5 (cl (+ p) (+ q)) &lt;proof&gt;)</code>
is a trivial proof of the clause <code>(cl (+ p) (+ q))</code>.</p>
<p>The serialization might use &quot;@&quot; instead of &quot;ref&quot;.</p>
</li>
<li>
<p><strong>refl</strong> (<code>(refl &lt;term&gt;)</code>): <code>(refl t)</code> is a proof of the
clause <code>(cl (+ (= t t)))</code>.</p>
</li>
<li>
<p><strong>assert</strong> (<code>(assert &lt;term&gt;)</code>): proves a unit clause <code>(cl (+ t))</code> (if
the term is <code>t</code>), but only if it matches exactly
an assertion/hypothesis of the original problem.</p>
<p>(TODO: be able to refer to the original formula by file+name if it was provided)</p>
</li>
<li>
<p><strong>hres</strong> (<code>(hres &lt;proof&gt; &lt;hstep&gt;+)</code>): a fold-like operation on the
initial proof's result. It can represent a resolution step, or hyper-resolution,
or some boolean paramodulation steps. As opposed to the other rules which
are mostly useful for preprocessing/simplification of the original problem,
this is expected to be one of the main inference rules
for resolution/superposition provers.</p>
<p>The proof step <code>(hres (init p0) h1 h2 … hn)</code> starts with the clause
<code>C0</code> obtained by validating <code>p0</code>. It then applies each &quot;h-step&quot; in the order
they are presented. Assuming the current clause is <code>C == (cl l1 … lm)</code>,
each h-step can be one of the following:</p>
<ul>
<li>
<p><strong>resolution</strong> (<code>(r &lt;term&gt; &lt;proof&gt;)</code>): <code>(r t proof)</code>
resolves <code>proof</code> into a clause <code>D</code> which must contain a literal
<code>(+ t)</code> or <code>(- t)</code>. Then it performs boolean resolution between
the current clause <code>C</code> and the clause <code>D</code> with pivot literal <code>(+ t)</code>.</p>
<p>Without loss of generality let's assume the proof returns <code>D</code>
where \( D \triangleq D' \lor (+ t) \), and \( C \triangleq C' \lor (- t) \).
Then the new clause is \( C' \lor D' \).</p>
</li>
<li>
<p><strong>unit resolution</strong> (<code>(r1 &lt;proof&gt;)</code>): <code>(r1 proof)</code> resolves <code>proof</code> into a clause <code>D</code>
which <em>must</em> be a unit-clause (i.e. exactly one literal).
Since there is not ambiguity on the pivot, it performs unit resolution
between <code>C</code> and <code>D</code> on the unique literal of <code>D</code>.</p>
</li>
<li>
<p><strong>boolean-paramodulation</strong> (<code>(p &lt;term&gt; &lt;term&gt; &lt;proof&gt;)</code>):
<code>(p lhs rhs proof)</code> resolves <code>proof</code> into a clause
<code>D</code> which must contain a literal <code>(+ (= lhs rhs))</code>, where both
<code>lhs</code> and <code>rhs</code> are boolean terms.
In other words, \( D \triangleq lhs = rhs \lor D' \).</p>
<p>The current clause <code>C</code> must contain a literal <code>(± lhs)</code>;
ie. \( C \triangleq C' \lor ± lhs \).</p>
<p>the result is obtained by replacing <code>lhs</code> with <code>rhs</code> in <code>C</code> and
adding <code>D'</code> back. Mathematically:</p>
<p>\[
\cfrac{
lhs = rhs \lor D'
\qquad
lhs \lor C'
}{
C' \lor D' \lor rhs
}
\]</p>
</li>
<li>
<p><strong>unit-boolean-paramodulation</strong> (<code>(p1 &lt;proof&gt;)</code>):
Same as <code>p</code> but the proof must return a unit clause <code>(+ (= lhs rhs))</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>r</strong> (<code>(r &lt;term&gt; &lt;proof&gt; &lt;proof&gt;)</code>): resolution on the given pivot
between the two clauses.</p>
<p>The proof term <code>(r pivot p1 p2)</code> corresponds to <code>(hres p1 (r pivot p2))</code>.</p>
<p>The shortcut <code>(r1 &lt;proof&gt; &lt;proof&gt;)</code> allows the user to omit the
pivot <strong>if</strong> one the the two proofs is unit (ie. has exactly one literal).</p>
<p>The proof term <code>(r1 p1 p2)</code> corresponds to <code>(hres p1 (r1 p2))</code>.</p>
</li>
<li>
<p><strong>cc-lemma</strong> (<code>(cc-lemma &lt;clause&gt;)</code>): proves a clause <code>c</code> if it's a
tautology of the theory of equality. There should generally be
n negative literals and one positive literal, all of them equations.</p>
<p>An example:</p>
<pre><code>(cc-lemma
  (cl
    (- (= a b))
    (- (= (f b) c))
    (- (= c c2))
    (- (= (f c2) d))
    (+ (= (f (f a)) d))))
</code></pre>
</li>
<li>
<p><strong>cc-imply</strong> (<code>(cc-imply (&lt;proof&gt;*) &lt;term&gt; &lt;term&gt;)</code>): a shortcut step
that combines <code>cc-lemma</code> and <code>hres</code> for more convenient proof production.
Internally the checker should be able to reuse most of the implementation
logic of <code>cc-lemma</code>.</p>
<p><code>(cc-imply (p1 … pn) t u)</code> takes <code>n</code> proofs, all of which must have
unit equations as their conclusions (say, <code>p_i</code> proves <code>(cl (+ (= t_i u_i)))</code>);
and two terms <code>t</code> and <code>u</code>;
and it returns a proof of <code>(cl (+ (= t u)))</code> if
the clause <code>(cl (- (= t_1 u_1)) (- (= t_2 u_2)) … (- (= t_n u_n)) (+ (= t u)))</code>
is a valid equality lemma (one that <code>cc-lemma</code> would validate).</p>
<p>In other words, <code>(cc-lemma (p1…pn) t u)</code>
could be expanded (using fresh names for steps) to:</p>
<pre><code>(steps ()
  ((stepc c_1 (cl (+ (= t_1 u_1))) p_1)
   (stepc c_2 (cl (+ (= t_2 u_2))) p_2)
   …
   (stepc c_n (cl (+ (= t_n u_n))) p_n)
   (stepc the_lemma
    (cl (- (= t_1 u_1)) (- (= t_2 u_2)) … (- (= t_n u_n)) (+ (= t u)))
    (cc-lemma
      (cl (- (= t_1 u_1)) (- (= t_2 u_2)) … (- (= t_n u_n)) (+ (= t u)))))
   (stepc res (cl (+ (= t u)))
    (hres
      (init (ref the_lemma))
      (r1 (ref c_1))
      (r1 (ref c_2))
      …
      (r1 (ref c_n))))))
</code></pre>
</li>
<li>
<p><strong>nn</strong> (<code>(nn &lt;proof&gt;)</code>): not-normalization: a normalization step that
transforms some literals in a clause. It turns <code>(- (not a))</code> into <code>(+ a)</code>,
and <code>(+ (not a))</code> into <code>(- a)</code>.</p>
</li>
<li>
<p><strong>bool-c</strong> (<code>(bool-c &lt;name&gt; &lt;term&gt;+)</code>): <code>(bool-c &lt;name&gt; &lt;terms&gt;)</code>
proves a boolean tautology of depth 1 using the
particular sub-rule named <code>&lt;name&gt;</code> with some term argument(s).
In other words, it corresponds to one construction or destruction axioms for
the boolean connective <code>and</code>, <code>or</code>, <code>=&gt;</code>, boolean <code>=</code>, <code>xor</code>, <code>not</code>.</p>
<p>The possible axioms are:</p>
<table><thead><tr><th>rule</th><th>axiom</th></tr></thead><tbody>
<tr><td><code>(and-i (and A1…An))</code></td><td><code>(cl (- A1) … (- An) (+ (and A1…An)))</code></td></tr>
<tr><td><code>(and-e (and A1…An) Ai)</code></td><td><code>(cl (- (and A1…An)) (+ Ai))</code></td></tr>
<tr><td><code>(or-e (or A1…An))</code></td><td><code>(cl (- (or A1…An)) (+ A1) … (+ An))</code></td></tr>
<tr><td><code>(or-i (or A1…An) Ai)</code></td><td><code>(cl (- Ai) (+ (or A1…An)))</code></td></tr>
<tr><td><code>(imp-e (=&gt; A1…An B))</code></td><td><code>(cl (- (=&gt; A1…An B)) (- A1)…(- An) (+ B))</code></td></tr>
<tr><td><code>(imp-i (=&gt; A1…An B) Ai)</code></td><td><code>(cl (+ Ai) (+ (=&gt; A1…An B)))</code></td></tr>
<tr><td><code>(imp-i (=&gt; A1…An B) B)</code></td><td><code>(cl (- B) (+ (=&gt; A1…An B)))</code></td></tr>
<tr><td><code>(not-e (not A))</code></td><td><code>(cl (- (not A)) (+ A))</code></td></tr>
<tr><td><code>(not-i (not A))</code></td><td><code>(cl (- A) (+ (not A))</code></td></tr>
<tr><td><code>(eq-e (= A B) A)</code></td><td><code>(cl (- (= A B)) (- A) (+ B))</code></td></tr>
<tr><td><code>(eq-e (= A B) B)</code></td><td><code>(cl (- (= A B)) (- B) (+ A))</code></td></tr>
<tr><td><code>(eq-i+ (= A B))</code></td><td><code>(cl (+ A) (+ B) (+ (= A B)))</code></td></tr>
<tr><td><code>(eq-i- (= A B))</code></td><td><code>(cl (- A) (- B) (+ (= A B)))</code></td></tr>
<tr><td><code>(xor-e- (xor A B))</code></td><td><code>(cl (- (xor A B)) (- A) (- B))</code></td></tr>
<tr><td><code>(xor-e+ (xor A B))</code></td><td><code>(cl (- (xor A B)) (+ A) (+ B))</code></td></tr>
<tr><td><code>(xor-i (xor A B) B)</code></td><td><code>(cl (+ A) (- B) (+ (xor A B)))</code></td></tr>
<tr><td><code>(xor-i (xor A B) A)</code></td><td><code>(cl (- A) (+ B) (+ (xor A B)))</code></td></tr>
</tbody></table>
</li>
<li>
<p><strong>bool-eq</strong> (<code>(bool-eq &lt;term&gt; &lt;term&gt;)</code>): <code>(bool-eq t u)</code> proves
the clause <code>(cl (+ (= t u)))</code> (where <code>t</code> and <code>u</code> are both boolean terms)
if <code>t</code> simplifies to <code>u</code> via a basic simplification step.</p>
<p>This rule corresponds to the axioms:</p>
<p><strong>TODO</strong>: also give names to sub-rules here</p>
<table><thead><tr><th>axiom</th></tr></thead><tbody>
<tr><td><code>(= (not true) false)</code></td></tr>
<tr><td><code>(= (not false) true)</code></td></tr>
<tr><td><code>(= (not (not t)) t)</code></td></tr>
<tr><td><code>(= (= true A) A)</code></td></tr>
<tr><td><code>(= (= false A) (not A))</code></td></tr>
<tr><td><code>(= (xor true A) (not A))</code></td></tr>
<tr><td><code>(= (xor false A) A)</code></td></tr>
<tr><td><code>(= (= t t) true)</code></td></tr>
<tr><td><code>(= (or t1…tn true u1…um) true)</code></td></tr>
<tr><td><code>(= (or false false) false)</code></td></tr>
<tr><td><code>(= (=&gt; true A) A)</code></td></tr>
<tr><td><code>(= (=&gt; false A) true)</code></td></tr>
<tr><td><code>(= (=&gt; A true) true)</code></td></tr>
<tr><td><code>(= (=&gt; A false) (not A))</code></td></tr>
<tr><td><code>(= (or false false) false)</code></td></tr>
<tr><td><code>(= (and t1…tn false u1…um) false)</code></td></tr>
<tr><td><code>(= (and true true) true)</code></td></tr>
</tbody></table>
</li>
<li>
<p><strong>\( \beta \)-reduction</strong> (<code>(beta-red &lt;term&gt; &lt;term&gt;)</code>):
Given <code>(lambda (x:τ) body)</code> and <code>u</code>, returns the clause
<code>(cl (+ (= ((lambda (x:τ) body) u) body[x := u])))</code>
where <code>body[x := u]</code> denotes the term obtained by substituting <code>x</code> with <code>u</code>
in <code>body</code> in a capture avoiding way.</p>
<p>Mathematically:
\[
\vdash (\lambda x:\tau. t)~ u = t[x := u]
\]</p>
</li>
</ul>
<!-- TODO? or unecessary?
- **\\( \eta \\)-expansion** (`(eta-exp <term>)`):
  Given a term `t` of arrow type `a → b`, returns the lemma
  `(cl (+ (= t ((lambda (x:a) t) x))))` for a variable `x` of type `a`.

  Mathematically:
  \\[
    (\lambda x:\tau. t)~ x = t
  \\]
  -->
<p>TODO: instantiation</p>
<p>TODO: reasoning under quantifiers</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="composite-rule"><a class="header" href="#composite-rule">Composite rule</a></h1>
<p>The main structuring construct for proofs is <code>steps</code>. Its structure is
<code>(steps (&lt;assumption&gt;*) (&lt;step&gt;+))</code>.</p>
<ul>
<li>
<p>Each <strong>assumption</strong> is a pair <code>(&lt;name&gt; &lt;literal&gt;)</code>.
As a reminder, literals are of the shape <code>(+ t)</code> or <code>(- t)</code>.</p>
<p>These assumptions can be used in the steps by using <code>(ref &lt;name&gt;)</code> (see below),
which is a trivial proof of the unit clause <code>(cl &lt;literal&gt;)</code>.</p>
</li>
<li>
<p>Each <strong>step</strong> is one of:</p>
<ul>
<li>
<p><strong>Term definition</strong> (<code>(deft &lt;name&gt; &lt;term&gt;)</code>), which introduces an
alias for a term. <code>&lt;name&gt;</code> must not be in the signature of the original problem.</p>
<p>Logically speaking, after <code>(deft c t)</code>, <code>c</code> and <code>t</code> are syntactically the
same. <code>c</code> has no real existence, it is only a shortcut, so a proof
of <code>(cl (+ (= c t)))</code> can be simply <code>(refl t)</code> (or <code>(refl c)</code>).</p>
</li>
<li>
<p><strong>Reasoning step</strong> (<code>(stepc &lt;name&gt; &lt;clause&gt; &lt;proof&gt;)</code>):
<code>(stepc name clause proof)</code> (where <code>name</code> must be fresh: be defined nowhere else)
introduces <code>name</code> as a shortcut for <code>proof</code> in the following steps.</p>
<p>The result of <code>proof</code> must be exactly <code>clause</code>, otherwise the step fails.
This means we can start <em>using</em> <code>(ref name)</code> in the following steps
before we validate <code>proof</code>, since we know the result ahead. In a
high-performance proof checker this is a good opportunity for parallelisation,
where <code>proof</code> can be checked in parallel with other steps that make use of its
result.</p>
</li>
</ul>
</li>
<li>
<p>The result of <code>(steps (A1 … Am) (S1 … Sn))</code>, where the last step
<code>Sn</code> has as conclusion a clause <code>C</code> with literals <code>(cl l1 … ln)</code>,
is the clause <code>(cl l1 … ln ¬A1 … ¬Am)</code>.</p>
<p>In particular, if <code>Sn</code> proves the empty clause, then <code>(steps …)</code> proves
that at least one assumption must be false. If both <code>Sn</code>'s conclusion
and the list of assumptions are empty, then
the result is the empty clause.</p>
</li>
<li>
<p>The list of assumptions can be useful either for subproofs,
or to produce a proof of unsatisfiability for
the SMTLIB v2.6 statement <code>(check-sat-assuming (&lt;lit&gt;+))</code>.</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="box-rules"><a class="header" href="#box-rules">Box rules</a></h1>
<p>Box is a term constructor that allows abstracting a clause into an opaque
constant term. This way, a whole clause can become a literal in another clause
without having to deal with true nested clauses;
see <a href="reference/./terms.html">the section on terms</a> for more details.</p>
<p>First, a few remarks.</p>
<ul>
<li><code>(box C)</code> and <code>(box D)</code> are syntactically the same term if and only if (iff)
<code>C</code> and <code>D</code> are the same clause, modulo renaming of free variables
and reordering of literals.</li>
<li><code>(box C)</code> is opaque and will not be traversed by congruence closure.</li>
</ul>
<p>That said, we have a few rules to deal with boxes:</p>
<ul>
<li>
<p><strong>box-assume</strong> (<code>(box-assume &lt;clause&gt;)</code>):
<code>(box-assume c)</code>, where <code>c</code> is <code>(cl l1 l2 … ln)</code>,
proves the tautology <code>(cl (- (box c)) l1 l2 … ln)</code>.</p>
<p>If one erases box (which is, semantically, transparent), this corresponds to
the tautology \( \lnot (\forall \vec{x} C) \lor \forall \vec{x} C \)
where \( \vec{x} \) is the set of free variables in \( C \).</p>
<p>The use-case for this rule is that we can assume <code>C</code> freely and use it
in the rest of the proof, <em>provided</em> we keep an assumption <code>(box C)</code> around
in a negative literal. Once we actually prove <code>C</code> we can discharge <code>(box C)</code>.</p>
</li>
<li>
<p><strong>box-proof</strong> (<code>(box-proof &lt;proof&gt;)</code>):
given a proof <code>p</code> with conclusion <code>C</code>, this returns a proof
whose conclusion is <code>(box C)</code>. Semantically it does nothing.</p>
</li>
</ul>
<p>An interesting possibility offered by <code>box</code> is simplifications in a tactic framework.
A simplification rule might take a <em>goal</em> clause <code>A</code>, and simplify it
into a goal clause <code>B</code>. To justify this, the theorem prover might produce
a proof <code>(cl (- (box B)) l1 … ln)</code> (assuming <code>A</code> is <code>(cl l1 … ln)</code>)
which means \( B \Rightarrow A \). 
It might do that by starting with <code>(box-assume B)</code> and applying the rewrite
steps backward to get back to the literals of <code>A</code>.</p>
<p>Once the goal <code>B</code> is proved, we obtain a proof of <code>B</code> which we can lift
to a proof of <code>(cl (+ (box B)))</code> using <code>box-lift</code>; then we only have to do unit-resolution
on <code>(cl (+ (box B)))</code> and <code>(cl (- (box B)) l1 … ln)</code> to
obtain <code>(cl l1 … ln)</code>, ie. was the original goal <code>A</code>.</p>
<p>Another possibility is to box a full clause, and use it as an assumption
in a sub-proof <code>steps</code>. Then <code>box-assume</code> is required to make use of the assumption.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="full-example"><a class="header" href="#full-example">Full example</a></h1>
<p>We're going to explore a bigger example: the proof of unsatisfiability
of the SMTLIB problem <code>QF_UF/eq_diamond/eq_diamond2.smt2</code>.</p>
<p>It starts normally:</p>
<pre><code class="language-smt2">(quip 1
 (steps ()
</code></pre>
<p>followed by a bundle of term definitions for better sharing
(note that the <code>_tseitin_xxx</code> symbols are actually introduced by Sidekick
during clausification; they're not just proof printing artefacts):</p>
<pre><code class="language-smt2">  ((deft $t1 (= x0 y0))
   (deft $t2 (= y0 x1))
   (deft $t3 (and $t1 $t2))
   (deft _tseitin_and_0 (and $t1 $t2))
   (deft $t4 (= x0 z0))
   (deft $t5 (= x1 z0))
   (deft $t6 (and $t4 $t5))
   (deft _tseitin_and_1 (and $t4 $t5))
   (deft $t7 (or $t3 $t6))
   (deft _tseitin_or_2 (or $t3 $t6))
   (deft $t8 (= x0 x1))
   (deft $t9 (not $t8))
   (deft $t10 (and $t7 $t9))
   (deft _tseitin_and_3 (and $t7 $t9))
</code></pre>
<p>and then the actual proof:</p>
<pre><code class="language-smt2">   (stepc c0 (cl (- $t1) (- $t2) (+ $t8))
    (cc-lemma (cl (- $t1) (- $t2) (+ $t8))))
   (stepc c1 (cl (- _tseitin_and_3) (- $t8))
    (bool-c (cl (- $t8) (- _tseitin_and_3))))
   (stepc c2 (cl (+ _tseitin_and_3))
    (hres (init (assert $t10))
     (p1
      (cc-lemma-imply (refl $t10))
       (= $t10 _tseitin_and_3))))
   (stepc c3 (cl (- $t8)) (hres (init (ref c1)) (r1 (ref c2))))
   (stepc c4 (cl (- _tseitin_and_0) (+ $t2))
    (bool-c (cl (+ $t2) (- _tseitin_and_0))))
   (stepc c5
    (cl (- _tseitin_or_2) (+ _tseitin_and_1) (+ _tseitin_and_0))
    (bool-c (cl (+ _tseitin_and_1) (+ _tseitin_and_0) (- _tseitin_or_2))))
   (stepc c6 (cl (- $t4) (- $t5) (+ $t8))
    (cc-lemma (cl (- $t4) (- $t5) (+ $t8))))
   (stepc c7 (cl (- $t5) (- $t4))
    (hres (init (ref c6)) (r1 (ref c3))))
   (stepc c8 (cl (- _tseitin_and_1) (+ $t4))
    (bool-c (cl (+ $t4) (- _tseitin_and_1))))
   (stepc c9 (cl (- _tseitin_and_1) (+ $t5))
    (bool-c (cl (+ $t5) (- _tseitin_and_1))))
   (stepc c10 (cl (- _tseitin_and_1))
    (hres (init (ref c7)) (r (pivot $t5) (ref c9))
      (r (pivot $t4) (ref c8))))
   (stepc c11 (cl (- _tseitin_and_3) (+ _tseitin_or_2))
    (bool-c (cl (+ _tseitin_or_2) (- _tseitin_and_3))))
   (stepc c12 (cl (+ _tseitin_or_2))
    (hres (init (ref c11)) (r1 (ref c2))))
   (stepc c13 (cl (+ _tseitin_and_0))
    (hres (init (ref c5)) (r1 (ref c12)) (r1 (ref c10))))
   (stepc c14 (cl (+ $t2)) (hres (init (ref c4)) (r1 (ref c13))))
   (stepc c15 (cl (- _tseitin_and_0) (+ $t1))
    (bool-c (cl (+ $t1) (- _tseitin_and_0))))
   (stepc c16 (cl (+ $t1))
    (hres (init (ref c15)) (r1 (ref c13))))
   (stepc c17 (cl )
    (hres (init (ref c0)) (r1 (ref c16))
     (r1 (ref c14)) (r1 (ref c3)))))))
</code></pre>
<p>Note that the last step returns the empty clause, which means we did prove
the problem to be unsatisfiable:</p>
<pre><code class="language-smt2">   (stepc c17 (cl )
    (hres (init (ref c0)) (r1 (ref c16))
     (r1 (ref c14)) (r1 (ref c3)))))))
</code></pre>
<p>Let's examine a few steps.</p>
<ul>
<li>
<p><code>c0</code>:</p>
<pre><code>(stepc c0 (cl (- $t1) (- $t2) (+ $t8))
  (cc-lemma (cl (- $t1) (- $t2) (+ $t8))))
</code></pre>
<p>which means that \( x0 = y0, y0 = x1 \vdash x0 = x1 \) is a tautology
of the theory of equality. Indeed it is, it's the transitivity axiom.</p>
</li>
<li>
<p><code>c3</code>:</p>
<pre><code>(stepc c3 (cl (- $t8)) (hres (init (ref c1)) (r1 (ref c2))))
</code></pre>
<p>Here, we have:</p>
<ul>
<li><code>c1</code> is <code>(cl (- _tseitin_and_3) (- (= x0 x1))</code></li>
<li><code>c2</code> is <code>(cl (+ _tseitin_and_3))</code></li>
<li>so, by resolution of <code>c1</code> and <code>c2</code>
(note the use of &quot;r1&quot; since <code>c2</code> is unit: we do
not need to specify a pivot) we obtain <code>(cl (- (= x0 x1)))</code>.</li>
</ul>
</li>
<li>
<p><code>c4</code>:</p>
<pre><code>(stepc c4 (cl (- _tseitin_and_0) (+ $t2))
 (bool-c (cl (+ $t2) (- _tseitin_and_0))))
</code></pre>
<p>where <code>_tseitin_and_0</code> is actually a name for <code>(and $t1 $t2)</code>.</p>
<p>The <code>bool-c</code> rule is valid since <code>(cl (+ $t2) (- (and $t1 $t2)))</code>
is one of the basic tautology on the <code>and</code> boolean connective.</p>
</li>
<li>
<p><code>c10</code>:</p>
<pre><code>(stepc c10 (cl (- _tseitin_and_1))
 (hres (init (ref c7)) (r (pivot $t5) (ref c9))
   (r (pivot $t4) (ref c8))))
</code></pre>
<p>We have:</p>
<ul>
<li><code>c7</code> is <code>(cl (- $t5) (- $t4))</code></li>
<li><code>c9</code> is <code>(cl (- _tseitin_and_1) (+ $t5))</code></li>
<li><code>c8</code> is <code>(cl (- _tseitin_and_1) (+ $t4))</code></li>
</ul>
<p>And the hyper-resolution steps therefore go:</p>
<table><thead><tr><th>clause</th><th>step</th></tr></thead><tbody>
<tr><td><code>(cl (- $t5) (- $t4))</code></td><td>start with <code>c7</code></td></tr>
<tr><td><code>(cl (- $t4) (- _tseitin_and_1))</code></td><td>resolve with <code>c9</code> on <code>$t5</code></td></tr>
<tr><td><code>(cl (- _tseitin_and_1))</code></td><td>resolve with <code>c8</code> on <code>$t4</code></td></tr>
</tbody></table>
</li>
<li>
<p><code>c17</code>:</p>
<pre><code>(stepc c17 (cl)
 (hres (init (ref c0)) (r1 (ref c16))
  (r1 (ref c14)) (r1 (ref c3)))))))
</code></pre>
<p>We prove the empty clause! Here we have:</p>
<ul>
<li><code>c0</code> is <code>(cl (- $t1) (- $t2) (+ $t8))</code></li>
<li><code>c16</code> is <code>(cl (+ $t1))</code></li>
<li><code>c14</code> is <code>(cl (+ $t2))</code></li>
<li><code>c3</code> is <code>(cl (- $t8))</code></li>
</ul>
<p>So by starting with <code>c0</code> and performing unit resolution steps we get:</p>
<table><thead><tr><th>clause</th><th>step</th></tr></thead><tbody>
<tr><td><code>(cl (- $t1) (- $t2) (+ $t8))</code></td><td>start with <code>c0</code></td></tr>
<tr><td><code>(cl (- $t2) (+ $t8))</code></td><td>unit-resolve with <code>c16</code></td></tr>
<tr><td><code>(cl (+ $t8))</code></td><td>unit-resolve with <code>c14</code></td></tr>
<tr><td><code>(cl )</code></td><td>unit-resolve with <code>c3</code></td></tr>
</tbody></table>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="more-on-boxing"><a class="header" href="#more-on-boxing">More on boxing</a></h1>
<p>If two clauses <code>C</code> and <code>D</code> are known to be equivalent, but are not syntactically the same,
one can prove <code>(cl (- (box C)) (+ (box D)))</code> (and conversely) as follows.</p>
<p>Let's assume <code>C</code> is <code>(cl (+ a) (+ b))</code>, <code>D</code> is <code>(cl (+ a2) (+ b2))</code>,
and we have some clauses <code>PA</code> and <code>PB</code> proving <code>(= a a2)</code> and <code>(= b b2)</code>:</p>
<pre><code>(steps
 ((hyp_bc (box C)))
 (
  ; first use box-assume
  (stepc s1 (cl (- (box C)) (+ a) (+ b)) (box-assume C))

  ; discharge the box locally using the assumption
  (stepc s2 (cl (+ a) (+ b))
    (hres (init (ref s1)) (r1 (ref hyp_bc))))

  ; prove D
  (stepc s3 (cl (+ a2) (+ b2))
    (hres
      (init (res s2))
      (p1 (ref PA)) ; a=a2
      (p1 (ref PB)) ; b=b2
      ))

  ; box D
  (stepc s4 (cl (+ (box D)))
    (box-proof (ref s3)))))
</code></pre>
<p>Because we add the negation of the assumptions,
the result of this sub-proof
is thus <code>(cl (- (box C)) (+ (box D)))</code>.</p>
<p>We used the assumption mechanism to get rid of <code>(- (box C))</code> locally
to avoiding boxing it along with the other literals
when we apply <code>box-proof</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>Here is a list of tools that can produce or consume Quip proofs.</p>
<h2 id="proof-producing-provers-and-smt-solvers"><a class="header" href="#proof-producing-provers-and-smt-solvers">Proof-producing provers and SMT solvers</a></h2>
<ul>
<li><a href="https://github.com/c-cube/sidekick">sidekick</a> (WIP)</li>
</ul>
<p>TODO: zipperposition</p>
<h2 id="proof-checking-tools"><a class="header" href="#proof-checking-tools">Proof-checking tools</a></h2>
<p>TODO: reference checker</p>
<h2 id="others"><a class="header" href="#others">Others</a></h2>
<p>TODO: proof-to-dot and others</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
