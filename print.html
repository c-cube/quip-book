<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quip: Quick Proofs</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/design.html"><strong aria-hidden="true">1.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="intro/example.html"><strong aria-hidden="true">1.2.</strong> Example</a></li><li class="chapter-item expanded "><a href="intro/for-atp.html"><strong aria-hidden="true">1.3.</strong> For the Theorem Prover</a></li><li class="chapter-item expanded "><a href="intro/for-proof-checkers.html"><strong aria-hidden="true">1.4.</strong> For the Proof Checker</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">2.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/terms.html"><strong aria-hidden="true">2.1.</strong> Terms</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Substitutions</div></li><li class="chapter-item expanded "><a href="reference/clauses.html"><strong aria-hidden="true">2.3.</strong> Clauses</a></li><li class="chapter-item expanded "><a href="reference/rules.html"><strong aria-hidden="true">2.4.</strong> Proof Rules</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> S-expression Format</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Binary Format</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Quip: Quick Proofs</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Quip documentation. Quip (&quot;Quick Proofs&quot;) is an experimental
proof format for first-order and higher-order automatic theorem provers,
designed to be easy to produce, and reasonably easy to check.</p>
<p>There are two sides to this documentation:</p>
<ul>
<li>the point of view of theorem provers, SMT solvers, etc.
that might <em>produce</em> Quip proofs;</li>
<li>the point of view of proof checkers that aim at validating such proofs.</li>
</ul>
<p><strong>NOTE</strong>: the proof format is experimental and its design will most likely
fluctuate a lot for a while as checkers and proof-producing provers are
developed.</p>
<h2 id="overall-design"><a class="header" href="#overall-design">Overall design</a></h2>
<p>A Quip proof is organized around a few main notions: <em>terms</em>, <em>substitutions</em>,
<em>clauses</em>, and <em>proof steps</em>.</p>
<ul>
<li>
<p><strong>Terms</strong> are expressions in a simple higher-order logic similar to the ones
of HOL light, HOL, Isabelle/HOL, etc. It features prenex polymorphism,
applications, equality, variables, and lambda abstractions.</p>
<p>An example term might be \(  p~ x = (\lambda y. f~ x~ y = y) \)
where \( p \) is a predicate symbol and \( f \) a function symbol.
We use here a ML-like syntax with currying.</p>
</li>
<li>
<p><strong>Substitutions</strong> are finite mappings from variables to terms,
noted as such: \( \{ x_1 \mapsto t_1, \ldots, x_n \mapsto t_n \} \).</p>
<p><em>Applying</em> a substitution to a term yields a new term, where the variables
have been replaced by their image in the substitution (or kept if they're
not bound in the substitution)</p>
</li>
<li>
<p><strong>Clauses</strong> are sets of literals<sup class="footnote-reference"><a href="#1">1</a></sup>, where each literal is a tuple
\( sign, term \). The <em>sign</em> of a literal is a boolean
that indicates whether the term is positive (<code>true</code>) or negative (<code>false</code>).
A negative literal <code>(false, t)</code> fundamentally <em>represents</em> \( \lnot t \)
but is distinct from the term \( \lnot t \) because the polarity (the sign)
is only relevant in the context of a clause.</p>
<p>We will denote a negative literal as \( - t \) and a positive
literal as \( + t \).</p>
<p>An example clause might be: \[ \{ - (a=b), - (c=d), + ((f~ a~ c) = (~f b~ d)) \} \]
It represents the basic congruence lemma:
\[ a=b, c=d \vdash f~ a~ c = f~ b~ d    \]</p>
</li>
<li>
<p><strong>Proof steps</strong> are the basic building blocks of proofs. A proof step
is composed of:</p>
<ul>
<li>a <strong>rule</strong>, which indicates how to process this step;</li>
<li>a <strong>conclusion</strong>, which is the clause that this proof step produces;</li>
<li>a set of <strong>premises</strong>, which are inputs to the proof step.</li>
<li>optionally, some additional arguments such as terms, substitutions, etc.</li>
</ul>
<p>A proof step asserts (via its particular rule) that the set of premises
implies its conclusion. In practice not all the elements of a step might be
explicitly written down! For example \( \text{refl}~ t \) (with \( t \) a term)
is a basic proof step with rule &quot;refl&quot;, no premises,
and conclusion  \( \{ + (t = t) \} \).</p>
</li>
</ul>
<p>A distinguishing feature of Quip compared to some other proof formats such as
the one in VeriT is that the rules are high-level and require proof checkers
to do more work in order to verify them. In exchange, the hope is that
we get more concise proofs that are also easier to produce from theorem provers.</p>
<p><strong>TODO</strong>: citations for VeriT</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Clauses can alternatively be seen as classical sequents, with negative elements
on the left of \( \vdash \), and positive elements on the right of it.</p>
</div>
<h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>This is a very simple SMT problem in the category <code>QF_UF</code>, representing
the problem \( a=b \land f~a = c \vdash f~b = c \) by trying to contradict it:</p>
<pre><code class="language-smtlib2">(set-logic QF_UF)
(declare-sort u 0)
(declare-fun a () u)
(declare-fun b () u)
(declare-fun c () u)
(declare-fun f (u) u)

(assert (= a b))
(assert (= (f a) c))
(assert (not (= (f b) c)))
(check-sat)
(exit)
</code></pre>
<p>With <a href="https://github.com/c-cube/sidekick">Sidekick</a>'s experimental
proof producing mode, we solve this problem (it replies &quot;UNSAT&quot;):</p>
<pre><code class="language-sh">$ sidekick example-pb.smt2 -o example-proof.quip
Unsat (0.003/0.000/0.000)
</code></pre>
<p>And we get the following proof:</p>
<pre><code class="language-sexp">(quip 1
 (steps ()
  ((deft $t1 (f a))
   (deft $t2 (= $t1 c))
   (deft $t3 (= a b))
   (deft $t4 (f b))
   (deft $t5 (= c $t4))
   (stepc c0 (cl (- $t2) (- $t3) (+ $t5))
    (cc-lemma (cl (- $t2) (- $t3) (+ $t5))))
   (stepc c1 (cl (- $t5))
    (hres (init (assert (not $t5))) (p1 (refl $t5))))
   (stepc c2 (cl (+ $t3))
    (hres (init (assert $t3)) (p1 (refl $t3))))
   (stepc c3 (cl (+ $t2))
    (hres (init (assert $t2)) (p1 (refl $t2))))
   (stepc c4 (cl )
    (hres
     (init (ref c0)) (r1 (ref c3))
     (r1 (ref c2)) (r1 (ref c1)))))))
</code></pre>
<p><strong>NOTE</strong>: the proof uses the S-expression format, but I do hope to have a
more efficient binary format relatively early on.</p>
<h2 id="detailed-explanation"><a class="header" href="#detailed-explanation">Detailed explanation</a></h2>
<ul>
<li>
<p>proof start with <code>(quip &lt;version&gt; &lt;proof&gt;)</code>. For now <code>version</code> is 1.</p>
</li>
<li>
<p><code>(steps (&lt;assumptions&gt;) (&lt;steps&gt;))</code> is the main composite proof rule.
Let's ignore the assumptions for now. Each step in this rule
is either a symbol definition (see below) or a <code>(stepc &lt;name&gt; &lt;clause&gt; &lt;proof&gt;)</code>,
which introduce a name for an intermediate lemma (the clause)
as proved by the sub-proof.</p>
<p>A side-effect of this is that you can have partially correct<sup class="footnote-reference"><a href="#1">1</a></sup> proofs
if a step is used correctly in the remainder of the proof, but its proof is
invalid.</p>
</li>
<li>
<p><code>(deft $t1 (f a))</code> is a term definition.
It defines the new symbol <code>$t1</code> as a syntactic shortcut for
the term <code>(f a)</code>, to be expanded as early as possible by the proof checker.</p>
<p>Similarly, <code>$t5</code> is short for <code>(= c (f b))</code>.</p>
<p>This kind of definition becomes important in larger proofs, where re-printing
a whole term every time it is used would be wasteful and would bloat proof
files. Using definitions we can preserve a lot of sharing in the proofs.</p>
</li>
<li>
<p><code>(stepc c0 â€¦)</code> is the first real step of the proof.
Here, <code>c0</code> is the clause <code>{ - $t2, - $t3, + $t5</code>,
and is proved by the proof <code>(cc-lemma â€¦)</code> (a congruence closure lemma,
i.e. a tautology of equality). It is, in essence, the proof we seek;
the rest of the steps are used to derive a contradiction by
deducing &quot;false&quot; from <code>c0</code> and our
initial assumptions.</p>
</li>
<li>
<p>the steps deducing <code>c1</code>, <code>c2</code>, and <code>c3</code> do so by using <code>assert</code>
(meaning that the clause is actually an assumption of the initial problem),
and then &quot;preprocessing&quot; them.</p>
<p>For <code>(stepc c1 (cl (- $t5)) (hres (init (assert (not $t5))) (p1 (refl $t5))))</code> we get the following
tree:</p>
<p>\[
\cfrac{
\cfrac{}{$t5 ~\tiny{(assume)}} \qquad
\cfrac{}{$t5 = $t5  ~\tiny{(refl)}}
}{$t5  ~\tiny{(para1)}}
\]</p>
<p>In this tree we can see the general shape of preprocessing terms: assume the
initial term <code>Â± t</code>, prove <code>+ (t = u)</code> (where <code>u</code> is the simplified version),
and then use boolean paramodulation to obtain <code>Â± u</code>.</p>
<p>It just so happens
that no meaningful simplification occurred and so <code>t</code> and <code>u</code> are the same,
and sidekick did not shorten the proof accordingly into
<code>(stepc c1 (cl (- $t5)) (assert (not $t5)))</code></p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>or partially incorrect, depending on your point of view. Glass half-full
and all that.</p>
</div>
<h2 id="quip-for-the-automatic-theorem-prover"><a class="header" href="#quip-for-the-automatic-theorem-prover">Quip for the Automatic Theorem Prover</a></h2>
<p>Quip is biased towards being easy to <em>produce</em> from theorem provers and SMT
solvers, while remaining reasonably efficient to check.</p>
<p>The easiness comes from several aspects:</p>
<ul>
<li>
<p>redundancy in rules: many rules will have a general form (e.g. a congruence
closure lemma, or hyper-resolution with \( n \) steps),
and some shorter forms for the common case (e.g. unary resolution
or the reflexivity rule).</p>
</li>
<li>
<p>rules can be quite high-level, requiring the proof checkers to reimplement
congruence closure, resolution, etc.</p>
</li>
<li>
<p>the proof rules do not need to always specify their result, only enough
information that the conclusion can be reconstructed.</p>
</li>
<li>
<p>proofs are based on a <em>proof language</em> (&quot;proof terms&quot;) that allow for easy
composition of several steps. This way it's not necessary to name each single
clause occurring in the proof.</p>
</li>
</ul>
<h1 id="quip-for-the-proof-checker"><a class="header" href="#quip-for-the-proof-checker">Quip for the Proof Checker</a></h1>
<p>Quip's design favors the production of proofs, not their checking. However,
proof checking should still be implementable in an efficient way.</p>
<p>A proof checker must implement a few core algorithms to be able to verify proofs
(not to mention the particular set of theories it might support).
These are:</p>
<ul>
<li>
<p><strong>Congruence Closure</strong>:
equality is central to Quip, and most equality proofs
will be of the shape \( t_1=u_1, \ldots, t_n = u_n \vdash t=u \).
These can be checked in \( O(n ~ log(n)) \) time using Congruence Closure
(See for example the [EGG paper]).</p>
</li>
<li>
<p><strong>Resolution</strong>: 
clause-level reasoning is done via multiple steps of resolution and
boolean paramodulation.</p>
<p>The core rules are resolution:</p>
<p>\[
\cfrac{C1 \lor l  \qquad         C2 \lor \lnot l}{ C1 \lor C2 }
\]</p>
<p>and boolean paramodulation (where \(t\) is a boolean term):</p>
<p>\[
\cfrac{C1 \lor (t = u)  \qquad         C2 \lor t}{ C1 \lor C2 \lor u }
\]</p>
<p>In practice, in the proof format, &quot;hres&quot; is the rule used to perform
a series of such steps from an initial clause.</p>
</li>
<li>
<p><strong>Instantiation</strong>:
A clause \( C \) contains free variables \( \{ x_1, \ldots, x_n \} \).
Given a substitution \( \sigma \triangleq \{ x_1 \mapsto t_1, \ldots, x_n \mapsto t_n \} \), we
can deduce \( C\sigma \).</p>
</li>
</ul>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This chapter contains<sup class="footnote-reference"><a href="#1">1</a></sup> a detailed specification of the proof language constructs.
For the concrete file formats, see <a href="">the S-expr format</a> and <a href="">Binary format</a> chapters.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>will eventually contain. ðŸ˜‡</p>
</div>
<h1 id="terms"><a class="header" href="#terms">Terms</a></h1>
<p>Terms belong to higher-order logic, with prenex polymorphism. In general
we denote terms as \( t \) or \( u \) (with indices if needed).</p>
<p>(TODO: provide some citations)</p>
<p>(TODO: specify types)</p>
<p>The term can be constructed in the following ways:</p>
<ul>
<li>
<p><strong>Variables</strong>, denoted \( x, y, z \). They can be free, or bound. Variables
are typed.</p>
</li>
<li>
<p><strong>Applications</strong>, denoted <code>(f t1 t2 t3)</code>. Partial applications are transparent,
meaning that <code>(f t1 t2 t3)</code> is short for <code>(((f t1) t2) t3)</code>.</p>
</li>
<li>
<p><strong>Constants</strong>, denoted \( a, b, c, f, g, h \)
(where \(a,b,c\) are of atomic type and \(f, g, h\)
are functions by convention).</p>
<p>Polymorphic constants are applied to type arguments. Quip does not accept
a term made of a partially applied constant: polymorphism constants must always
be applied to enough type arguments.</p>
<p><strong>NOTE</strong>:
This does <em>not</em> include constants introduced by the prover using <code>(deft &lt;name&gt; &lt;term&gt;)</code> steps.
In that construct, say <code>(deft c (f a b))</code>, <code>c</code> and <code>(f a b)</code> are considered syntactically
equal; the proof checker can just expand <code>c</code> into <code>(f a b)</code> at parse time
and then forget entirely about <code>c</code>.</p>
</li>
<li>
<p><strong>Binders</strong>, such as \( \lambda (x:ty). t \), or \( \forall (x:ty). t \).
The latter is a shortcut for the application
\( \text{forall}~ (\lambda (x:ty). term) \)
(where \( \text{forall} \) is a constant of type \( \Pi a. (a \to \text{bool}) \to \text{bool} \) ).</p>
</li>
</ul>
<p>With lambda-abstraction comes a handful of axioms:
\( \beta\)-reduction, and \( \eta \)-expansion
(more details in <a href="reference/./rules.html">the rules section</a>).</p>
<h1 id="proof-rules"><a class="header" href="#proof-rules">Proof Rules</a></h1>
<h1 id="proof-rules-1"><a class="header" href="#proof-rules-1">Proof Rules</a></h1>
<h2 id="mandatory-axioms"><a class="header" href="#mandatory-axioms">Mandatory axioms</a></h2>
<p>These axioms must be supported by all checkers.</p>
<ul>
<li><strong>\( \beta \)-reduction</strong>: TODO</li>
<li><strong>\( \eta \)-expansion</strong>: TODO</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
